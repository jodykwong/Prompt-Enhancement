#!/usr/bin/env python3
"""
演示版提示词增强器 - 不需要 API 密钥

这个版本使用预设的示例来演示提示词增强的效果，
无需实际调用 DeepSeek API，方便快速验证概念。

**重要说明**：
- 这是演示模式，使用预设的高质量示例
- 不是真实的 API 调用
- 用于展示提示词增强的预期效果
- 实际使用时请使用 prompt_enhancer.py（需要 API 密钥）

**使用方式**：
1. 通过命令行参数: python demo_enhancer.py "待增强的提示词"
2. 通过 Python API: enhancer = DemoPromptEnhancer(); result = enhancer.enhance("待增强的提示词")
3. 通过交互式输入: 运行脚本后按提示输入
"""

import time
from typing import Dict


# 预设的增强示例 - 展示增强效果
DEMO_ENHANCEMENTS = {
    "优化代码": """优化代码性能和质量。请按以下步骤进行：

1. 性能分析：
   - 使用性能分析工具识别瓶颈（如 cProfile、memory_profiler）
   - 分析时间复杂度和空间复杂度
   - 识别热点代码路径

2. 优化策略：
   - 算法优化：选择更高效的算法和数据结构
   - 代码优化：减少不必要的计算和内存分配
   - 并发优化：考虑使用多线程或异步处理（如适用）
   - 缓存优化：添加合理的缓存机制

3. 代码质量提升：
   - 提高代码可读性：清晰的命名、适当的注释
   - 遵循编码规范和最佳实践
   - 消除代码重复（DRY 原则）
   - 简化复杂逻辑

4. 测试验证：
   - 运行现有测试确保功能不变
   - 进行性能基准测试，对比优化前后
   - 验证边界条件和异常情况

5. 代码审查：确保优化后的代码易于维护和理解

验证标准：性能有明显提升（如响应时间减少、内存占用降低），代码质量提高，所有测试通过。""",

    "修复bug": """修复代码中的缺陷。请按以下步骤进行：

1. 问题定位：
   - 收集错误日志和堆栈跟踪信息
   - 复现问题，确定触发条件
   - 识别出现问题的具体代码位置

2. 原因分析：
   - 审查相关代码逻辑
   - 检查边界条件和异常情况处理
   - 分析是否存在逻辑错误、资源泄漏或并发问题

3. 实施修复：
   - 编写修复代码，针对根本原因而非症状
   - 确保修复不引入新问题
   - 添加必要的错误处理和日志记录

4. 测试验证：
   - 编写或更新单元测试覆盖该 bug
   - 验证修复后问题不再出现
   - 进行回归测试确保其他功能正常

5. 代码审查和文档：
   - 提交代码前进行自查
   - 在提交信息中清晰描述问题和解决方案
   - 更新相关文档（如需要）

验证标准：bug 完全修复，相关测试通过，无新增问题，代码符合规范。""",

    "添加用户登录功能": """实现用户登录功能模块。请按以下步骤进行：

1. 需求分析：
   - 确定登录方式（用户名/密码、邮箱、第三方登录等）
   - 明确安全要求（密码强度、加密方式、会话管理）
   - 定义用户体验流程（登录页面、错误提示、记住我等）

2. 数据库设计：
   - 设计用户表结构（用户ID、用户名、密码哈希、邮箱等）
   - 设计会话/令牌表（如使用 JWT 或 session）
   - 考虑索引优化和数据安全

3. 后端实现：
   - 实现用户注册接口（密码加密存储，使用 bcrypt 或 argon2）
   - 实现登录验证接口（验证凭证，生成会话/令牌）
   - 实现登出接口（清除会话）
   - 添加身份验证中间件保护需要登录的接口
   - 实现密码重置功能（可选）

4. 前端实现：
   - 创建登录表单页面
   - 实现表单验证（客户端和服务端双重验证）
   - 处理登录状态管理（存储令牌、更新 UI）
   - 实现错误提示和加载状态

5. 安全措施：
   - 防止 SQL 注入和 XSS 攻击
   - 实现登录失败次数限制（防暴力破解）
   - 使用 HTTPS 传输敏感信息
   - 实现 CSRF 保护

6. 测试：
   - 单元测试：测试各个函数和接口
   - 集成测试：测试完整登录流程
   - 安全测试：测试常见安全漏洞
   - 用户体验测试：确保流程顺畅

验证标准：用户能够成功注册和登录，密码安全存储，会话管理正确，通过安全测试，用户体验良好。""",

    "重构数据库查询模块，提高性能": """重构数据库查询模块以提升性能。请按以下步骤进行：

1. 性能分析：
   - 使用数据库查询分析工具（如 EXPLAIN、慢查询日志）
   - 识别慢查询和性能瓶颈
   - 分析查询频率和数据量
   - 监控数据库连接池使用情况

2. 优化策略设计：
   - 索引优化：为常用查询字段添加合适的索引
   - 查询优化：重写低效查询，避免 N+1 问题
   - 缓存策略：对频繁查询的数据添加缓存层（Redis、Memcached）
   - 连接池优化：调整连接池大小和超时设置
   - 考虑读写分离或分库分表（如数据量大）

3. 代码重构：
   - 抽象数据访问层，统一查询接口
   - 使用 ORM 的最佳实践（如 select_related、prefetch_related）
   - 实现查询结果缓存机制
   - 添加查询性能监控和日志

4. 数据库层面优化：
   - 优化表结构和字段类型
   - 添加必要的索引（注意不要过度索引）
   - 优化数据库配置参数
   - 定期维护（VACUUM、ANALYZE 等）

5. 测试验证：
   - 性能基准测试：对比优化前后的查询时间
   - 负载测试：模拟高并发场景
   - 功能测试：确保重构后功能正确
   - 监控生产环境性能指标

6. 文档和部署：
   - 更新技术文档和 API 文档
   - 制定灰度发布计划
   - 准备回滚方案

验证标准：查询性能显著提升（如响应时间减少 50%+），系统稳定性提高，所有功能测试通过，代码可维护性增强。""",

    "为 API 接口添加 rate limiting 功能": """为 API 接口实现速率限制（Rate Limiting）功能。请按以下步骤进行：

1. 需求分析：
   - 确定限流策略（按 IP、用户、API key 等）
   - 定义限流规则（如每分钟 100 次请求）
   - 考虑不同接口的不同限流需求
   - 确定超限后的响应方式（429 状态码、错误信息）

2. 技术方案选择：
   - 选择限流算法（令牌桶、漏桶、滑动窗口、固定窗口）
   - 选择存储方案（Redis、内存、数据库）
   - 考虑分布式环境下的一致性

3. 实现限流中间件：
   - 创建 rate limiting 中间件或装饰器
   - 实现请求计数和时间窗口管理
   - 使用 Redis 存储限流状态（推荐，支持分布式）
   - 实现限流规则配置（可配置化）

4. 响应处理：
   - 返回 429 Too Many Requests 状态码
   - 在响应头中添加限流信息：
     * X-RateLimit-Limit: 限流上限
     * X-RateLimit-Remaining: 剩余请求数
     * X-RateLimit-Reset: 重置时间
   - 提供清晰的错误信息

5. 配置和管理：
   - 实现限流规则的动态配置
   - 添加白名单机制（如内部服务）
   - 实现限流监控和告警
   - 提供限流统计和分析

6. 测试：
   - 单元测试：测试限流逻辑
   - 集成测试：测试中间件集成
   - 压力测试：验证高并发下的限流效果
   - 边界测试：测试临界值情况

7. 文档和部署：
   - 更新 API 文档，说明限流规则
   - 通知 API 使用者限流变更
   - 灰度发布，监控影响

验证标准：限流功能正常工作，超限请求被正确拒绝，响应头信息准确，不影响正常请求，系统性能稳定。"""
}


class DemoPromptEnhancer:
    """演示版提示词增强器 - 使用预设示例"""
    
    def __init__(self):
        """初始化演示增强器"""
        self.model = "demo-mode (预设示例)"
    
    def enhance(self, original_prompt: str) -> Dict[str, any]:
        """
        增强提示词（演示版）
        
        Args:
            original_prompt: 原始提示词
            
        Returns:
            包含增强结果的字典
        """
        start_time = time.time()
        
        # 模拟处理延迟
        time.sleep(0.5)
        
        # 查找最匹配的预设示例
        enhanced_prompt = self._find_best_match(original_prompt)
        
        processing_time = time.time() - start_time
        
        return {
            "original": original_prompt,
            "enhanced": enhanced_prompt,
            "processing_time": processing_time,
            "success": True,
            "error": None,
            "mode": "demo"
        }
    
    def _find_best_match(self, prompt: str) -> str:
        """查找最匹配的预设示例"""
        prompt_lower = prompt.lower()
        
        # 简单的关键词匹配
        for key, value in DEMO_ENHANCEMENTS.items():
            if key in prompt or any(word in prompt_lower for word in key.split()):
                return value
        
        # 如果没有匹配，返回通用增强
        return f"""执行任务：{prompt}

请按以下步骤进行：

1. 需求分析：
   - 明确任务的具体目标和范围
   - 识别相关的技术要求和约束条件
   - 确定成功标准

2. 方案设计：
   - 分析可行的实现方案
   - 选择最合适的技术栈和工具
   - 设计详细的实施步骤

3. 实施执行：
   - 按照设计方案逐步实现
   - 遵循最佳实践和编码规范
   - 添加必要的错误处理和日志

4. 测试验证：
   - 编写和运行测试用例
   - 验证功能正确性
   - 检查边界条件和异常情况

5. 文档和交付：
   - 更新相关文档
   - 进行代码审查
   - 确保代码质量

验证标准：任务完成，功能正确，测试通过，代码质量良好。"""


if __name__ == "__main__":
    import sys
    from prompt_enhancer import print_result
    
    if len(sys.argv) > 1:
        prompt = " ".join(sys.argv[1:])
        enhancer = DemoPromptEnhancer()
        result = enhancer.enhance(prompt)
        print_result(result)
    else:
        print("用法: python demo_enhancer.py <提示词>")
        print("或者运行 python demo_test.py 查看完整演示")

